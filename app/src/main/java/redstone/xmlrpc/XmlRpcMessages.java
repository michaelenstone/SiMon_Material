/*
    Copyright ï¿½ 2006 by Redstone Handelsbolag
    All Rights Reserved.

    The copyright to the source code herein is the property of
    Redstone Handelsbolag. The source code may be used and/or copied only
    with written permission from Redstone or in accordance with
    the terms and conditions stipulated in the agreement/contract
    under which the source code has been supplied.
*/

package redstone.xmlrpc;

/**
 *  Contains various messages generated by the library. The original messages are
 *  stored in XmlRpcMessages.properties, which may be overridden by creating
 *  additional locale specific bundles. This is achieved by placing a copy of
 *  XmlRpcMessages.properties with the locale specific suffix (like
 *  XmlRpcMessages_de.properties for German). The bundle will automatically be selected
 *  depending on the default locale of the JVM.
 *
 *  @author Greger Olsson
 */

public class XmlRpcMessages
{

    private enum XmlRpcClient {
        NetworkError,
        ParseError,
        Encoding
    }

    private enum XmlRpcServlet {
        Encoding,
        ServiceClassNotFound,
        ServiceClassNotInstantiable,
        ServiceClassNotAccessible,
        InvalidServicesFormat
    }

    private enum XmlRpcSerializer {
        UnsupportedType
    }

    private enum XmlRpcValue {
        IllegalDate,
        UnexpectedNestedValue
    }

    private enum XmlRpcParser {
        ReaderInstantiationError,
        ParsingError
    }

    private enum XmlRpcDispatcher {
        HandlerNotFound,
        InvalidMethodNameFormat,
        InvocationCancelled,
        ErrorSendingFault
    }

    private enum Base64 {
        InvalidDataLength
    }

    private enum ReflectiveInvocationHandler {
        MethodNotPublished,
        MethodDontExist
    }

    private enum IntrospectingSerializer {
        SerializationError
    }

    public static String getString(String key) {
        String message = null;

        String[] parts = key.split("\\.");

        if (parts[0].equals("XmlRpcClient")) {
            XmlRpcClient xmlRpcClient = XmlRpcClient.valueOf(parts[1]);
            switch (xmlRpcClient) {
                case NetworkError:
                    message = "A network error occurred.";
                    break;
                case ParseError:
                    message = "The response could not be parsed.";
                    break;
                case Encoding:
                    message = "UTF-8";
                    break;
            }
        } else if (parts[0].equals("XmlRpcServlet")) {
            XmlRpcServlet xmlRpcServlet = XmlRpcServlet.valueOf(parts[1]);
            switch (xmlRpcServlet) {
                case Encoding:
                    message = "UTF-8";
                    break;
                case ServiceClassNotFound:
                    message = "The service class cannot not found:";
                    break;
                case ServiceClassNotInstantiable:
                    message = "The service class cannot be instantiated:";
                    break;
                case ServiceClassNotAccessible:
                    message = "The service class is not accessible:";
                    break;
                case InvalidServicesFormat:
                    message = "The services parameter format is invalid:";
                    break;
            }
        } else if (parts[0].equals("XmlRpcSerializer")) {
            message = "Could not serialize response. Unsupported type:";
        } else if (parts[0].equals("XmlRpcValue")) {
            XmlRpcValue xmlRpcValue = XmlRpcValue.valueOf(parts[1]);
            switch (xmlRpcValue) {
                case IllegalDate:
                    message = "Illegal date encountered:";
                    break;
                case UnexpectedNestedValue:
                    message = "Nested value encountered for a non-composite value";
                    break;
            }
        } else if (parts[0].equals("XmlRpcParser")) {
            XmlRpcParser xmlRpcParser = XmlRpcParser.valueOf(parts[1]);
            switch (xmlRpcParser) {
                case ReaderInstantiationError:
                    message = "Could not instantiate XMLReader parser";
                    break;
                case ParsingError:
                    message = "A problem occured during parsing";
                    break;
            }
        } else if (parts[0].equals("XmlRpcDispatcher")) {
            XmlRpcDispatcher xmlRpcDispatcher = XmlRpcDispatcher.valueOf(parts[1]);
            switch (xmlRpcDispatcher) {
                case HandlerNotFound:
                    message = "The specified handler cannot be found";
                    break;
                case InvalidMethodNameFormat:
                    message = "Invalid method name format";
                    break;
                case InvocationCancelled:
                    message = "The invocation was cancelled by a processor object";
                    break;
                case ErrorSendingFault:
                    message = "Could not send fault back to client due to communication problems";
                    break;
            }
        } else if (parts[0].equals("Base64")) {
            message = "Error decoding BASE64 element: Miscalculated data length";
        } else if (parts[0].equals("ReflectiveInvocationHandler")) {
            ReflectiveInvocationHandler reflectiveInvocationHandler = ReflectiveInvocationHandler.valueOf(parts[1]);
            switch (reflectiveInvocationHandler) {
                case MethodNotPublished:
                    message = "The method has not been published or does not exist";
                    break;
                case MethodDontExist:
                    message = "The method cannot be found. Signature:";
                    break;
            }
        } else if (parts[0].equals("IntrospectingSerializer")) {
            message = "Could not serialize property:";
        } else {
            message = "!" + key + "!";
        }
        return message;
    }

}
